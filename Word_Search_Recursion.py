# Created by Aashish Adhikari at 11:57 AM 2/2/2021

'''
Time Complexity:
We first find the positions where this first letter of the word exists. O(mn)

Suppose there were k such positions. Then for each of those positions, we further search a maximum of the length of the word.
Hence, in tree structure, at each node, we are making 3 decision (the path we came from is ignored.) THe height of this 3-nary tree is going
to be a maximum of L, the length of the word. The max number of nodes in this tree is (3 ^ ( L + 1)) - 1  which is ~ (3 ^L)
Hence O( k. 3 ^L)

Space Complexity:

O(mn) to store the initial starting positions generated by the nested for loop.

For each node, we are passing a deepcopy of the visited nodes till now.
THe number of elements in such a visited set can have a maximum value equal to the length of the word, L.
Max number of nodes traversed ~ 3 ^ L.
Hence, O(L . (3 ^ L))

If we consider the recursive stack as well, it will store d number of elements maximum at any time where d is the depth of the tree.
O(L)

Hence, O(mn) + O(L . (3 ^L) ) + O(L) ~ O(L . (3 ^L) )



# This can be further optimized by calling recursion when checking for the first letter of the word.
'''

class Solution(object):


    def recursion(self, board, word, coordinate, index, visited):



        # base case
        if index == len(word)-1:
            if word[index] == board[coordinate[0]][coordinate[1]]:
                return True
            else:
                return False

        # logic
        if word[index] == board[coordinate[0]][coordinate[1]]:


            # further dfs to the children
            temp = copy.deepcopy(visited)
            for dir in self.dirs:

                row = dir[0] + coordinate[0]
                col = dir[1] + coordinate[1]

                if row >= 0 and col >= 0 and row < len(board) and col < len(board[0]) and (row,col) not in visited:

                    new_visited = copy.deepcopy(temp)
                    new_visited.add((row,col))
                    to_return = self.recursion(board, word, (row,col), index+1, new_visited)

                    if to_return:
                        return True
            return False




    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """


        if word == "":
            return True


        # find all the positions of the first letter

        hs =set()

        for i in range(len(board)):
            for j in range(len(board[0])):

                if board[i][j] == word[0]:

                    hs.add((i,j))

        # now do dfs for each of these coordinates
        to_return = False
        self.dirs = [[-1,0], [1,0], [0,-1], [0,1]]

        for coordinate in hs:
            visited = set()
            visited.add(coordinate)

            to_return = self.recursion(board, word, coordinate, 0, visited)
            if to_return:
                return True

        return False